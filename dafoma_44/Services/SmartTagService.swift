//
//  SmartTagService.swift
//  TimeMaster Sweet
//
//  Created by Вячеслав on 9/9/25.
//

import Foundation
import SwiftUI

@MainActor
class SmartTagService: ObservableObject {
    static let shared = SmartTagService()
    
    @Published var smartTags: [SmartTag] = []
    @Published var savedFilters: [SavedFilter] = []
    
    private let dataService = DataPersistenceService.shared
    
    private init() {
        loadSmartTags()
        loadSavedFilters()
        setupDefaultTags()
    }
    
    // MARK: - Smart Tags Management
    
    func loadSmartTags() {
        if let data = UserDefaults.standard.data(forKey: "smartTags"),
           let tags = try? JSONDecoder().decode([SmartTag].self, from: data) {
            smartTags = tags
        }
    }
    
    func saveSmartTags() {
        if let data = try? JSONEncoder().encode(smartTags) {
            UserDefaults.standard.set(data, forKey: "smartTags")
        }
    }
    
    func addSmartTag(_ tag: SmartTag) {
        smartTags.append(tag)
        saveSmartTags()
    }
    
    func updateSmartTag(_ tag: SmartTag) {
        if let index = smartTags.firstIndex(where: { $0.id == tag.id }) {
            smartTags[index] = tag
            saveSmartTags()
        }
    }
    
    func deleteSmartTag(_ tag: SmartTag) {
        smartTags.removeAll { $0.id == tag.id }
        saveSmartTags()
    }
    
    // MARK: - Auto-tagging
    
    func generateAutoTags(for text: String) -> [String] {
        let lowercaseText = text.lowercased()
        var suggestedTags: [String] = []
        
        // Check against existing smart tags
        for tag in smartTags {
            if tag.matches(text: text) {
                suggestedTags.append(tag.name)
                var updatedTag = tag
                updatedTag.incrementUsage()
                updateSmartTag(updatedTag)
            }
        }
        
        // Generate contextual tags based on keywords
        let contextualTags = generateContextualTags(from: lowercaseText)
        suggestedTags.append(contentsOf: contextualTags)
        
        // Remove duplicates and return
        return Array(Set(suggestedTags))
    }
    
    private func generateContextualTags(from text: String) -> [String] {
        var tags: [String] = []
        
        // Meeting-related keywords
        if text.contains("meeting") || text.contains("call") || text.contains("conference") {
            tags.append("meeting")
        }
        
        // Urgent keywords
        if text.contains("urgent") || text.contains("asap") || text.contains("emergency") {
            tags.append("urgent")
        }
        
        // Project keywords
        if text.contains("project") || text.contains("milestone") || text.contains("deliverable") {
            tags.append("project")
        }
        
        // Learning keywords
        if text.contains("learn") || text.contains("study") || text.contains("research") {
            tags.append("learning")
        }
        
        // Health keywords
        if text.contains("exercise") || text.contains("workout") || text.contains("health") {
            tags.append("health")
        }
        
        // Shopping keywords
        if text.contains("buy") || text.contains("purchase") || text.contains("shopping") {
            tags.append("shopping")
        }
        
        // Travel keywords
        if text.contains("travel") || text.contains("trip") || text.contains("flight") {
            tags.append("travel")
        }
        
        return tags
    }
    
    private func setupDefaultTags() {
        if smartTags.isEmpty {
            let defaultTags = [
                SmartTag(name: "urgent", color: "#ee004a", isAutoGenerated: true, keywords: ["urgent", "asap", "emergency", "critical"], category: .auto),
                SmartTag(name: "meeting", color: "#0278fc", isAutoGenerated: true, keywords: ["meeting", "call", "conference", "zoom"], category: .auto),
                SmartTag(name: "project", color: "#d300ee", isAutoGenerated: true, keywords: ["project", "milestone", "deliverable"], category: .auto),
                SmartTag(name: "learning", color: "#54b702", isAutoGenerated: true, keywords: ["learn", "study", "research", "course"], category: .auto),
                SmartTag(name: "health", color: "#54b702", isAutoGenerated: true, keywords: ["exercise", "workout", "health", "fitness"], category: .auto),
                SmartTag(name: "shopping", color: "#fff707", isAutoGenerated: true, keywords: ["buy", "purchase", "shopping", "store"], category: .auto),
                SmartTag(name: "travel", color: "#ff6b35", isAutoGenerated: true, keywords: ["travel", "trip", "flight", "vacation"], category: .auto)
            ]
            
            smartTags = defaultTags
            saveSmartTags()
        }
    }
    
    // MARK: - Saved Filters Management
    
    func loadSavedFilters() {
        if let data = UserDefaults.standard.data(forKey: "savedFilters"),
           let filters = try? JSONDecoder().decode([SavedFilter].self, from: data) {
            savedFilters = filters
        }
    }
    
    func saveSavedFilters() {
        if let data = try? JSONEncoder().encode(savedFilters) {
            UserDefaults.standard.set(data, forKey: "savedFilters")
        }
    }
    
    func addSavedFilter(_ filter: SavedFilter) {
        savedFilters.append(filter)
        saveSavedFilters()
    }
    
    func updateSavedFilter(_ filter: SavedFilter) {
        if let index = savedFilters.firstIndex(where: { $0.id == filter.id }) {
            savedFilters[index] = filter
            saveSavedFilters()
        }
    }
    
    func deleteSavedFilter(_ filter: SavedFilter) {
        savedFilters.removeAll { $0.id == filter.id }
        saveSavedFilters()
    }
    
    // MARK: - Smart Collections
    
    func createSmartCollection(name: String, criteria: FilterCriteria) -> SavedFilter {
        var filter = SavedFilter(name: name, description: "Smart collection")
        filter.searchText = criteria.searchText
        filter.selectedCategory = criteria.category
        filter.selectedPriority = criteria.priority
        filter.tags = criteria.tags
        filter.dateRange = criteria.dateRange
        filter.completionStatus = criteria.completionStatus
        
        return filter
    }
    
    func getRecommendedFilters(based tasks: [Task]) -> [SavedFilter] {
        var recommendations: [SavedFilter] = []
        
        // High priority tasks
        if tasks.filter({ $0.priority == .high || $0.priority == .critical }).count > 3 {
            var filter = SavedFilter(name: "High Priority", description: "Important tasks that need attention")
            filter.selectedPriority = .high
            filter.icon = "exclamationmark.triangle"
            filter.color = "#ee004a"
            recommendations.append(filter)
        }
        
        // Overdue tasks
        if tasks.filter({ $0.isOverdue }).count > 0 {
            var filter = SavedFilter(name: "Overdue", description: "Tasks that are past their deadline")
            filter.completionStatus = .overdue
            filter.icon = "clock.badge.exclamationmark"
            filter.color = "#ee004a"
            recommendations.append(filter)
        }
        
        // Work tasks
        if tasks.filter({ $0.category == .work }).count > 5 {
            var filter = SavedFilter(name: "Work Tasks", description: "All work-related tasks")
            filter.selectedCategory = .work
            filter.icon = "briefcase"
            filter.color = "#0278fc"
            recommendations.append(filter)
        }
        
        return recommendations
    }
    
    // MARK: - Tag Analytics
    
    func getTagUsageStats() -> [TagUsageStat] {
        return smartTags.map { tag in
            TagUsageStat(
                tag: tag,
                usageCount: tag.usageCount,
                lastUsed: tag.createdAt // Would be updated when tag is used
            )
        }.sorted { $0.usageCount > $1.usageCount }
    }
    
    func getMostUsedTags(limit: Int = 10) -> [SmartTag] {
        return smartTags.sorted { $0.usageCount > $1.usageCount }.prefix(limit).map { $0 }
    }
    
    func getUnusedTags() -> [SmartTag] {
        return smartTags.filter { $0.usageCount == 0 }
    }
    
    func cleanupUnusedTags() {
        let cutoffDate = Calendar.current.date(byAdding: .month, value: -3, to: Date()) ?? Date()
        smartTags.removeAll { $0.usageCount == 0 && $0.createdAt < cutoffDate && !$0.isAutoGenerated }
        saveSmartTags()
    }
}

struct FilterCriteria {
    var searchText: String?
    var category: TaskCategory?
    var priority: TaskPriority?
    var tags: [String]
    var dateRange: DateRange?
    var completionStatus: CompletionStatus
    
    init() {
        self.searchText = nil
        self.category = nil
        self.priority = nil
        self.tags = []
        self.dateRange = nil
        self.completionStatus = .all
    }
}

struct TagUsageStat: Identifiable {
    let id = UUID()
    let tag: SmartTag
    let usageCount: Int
    let lastUsed: Date
    
    var formattedLastUsed: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: lastUsed, relativeTo: Date())
    }
}
